# Append Only Logs

## Scenario
Your Phone and your computer have their own append only logs (which contains data generated on the respective clients) which should be merged. Your phone and computer are not online at the same time so they cannot agree to a common log while they are connected to each other. While either party is online, it tells its own log to other peers on the network. The peers accept the incoming log messages and can verify and distribute them.
When the other decive gets online in can query for the logs of the (known) other devices of the user. The incoming logs should be merged in order that the user hat the same state on both devices.

## Structure of the Append Only Logs
 
Every message
* contains a hash of the message before
* digest is signed with a log specific signing key
* digest & correct chain verifyable by every participant of the network

The log starts with its signing verification key.
Every Log has a lamport clock.

Singing each log with a per-log key prevents other from adding messages to the log.

## Merging Logs

Precondition: two logs which have the same base have added new messages.

Goal: Merge should lead to the same consistent log on both devices: The consistent log contains all messages generated by both Logs. __Should the hash of the last message in each log be equals after merging (which would imply same order of messages in both logs)?__

Log1 - Phone:
|Time|Content|Lamport Clock|Previous Message|
|---|---|---|---|
|6:00 |Message 0|0|-|
|7:00 |Message 1|1|Message 0|
|10:00 |Message 2|2|Message 1|
|11:00 |Message 3 (phone)|3|Message 2|
|18:30 |Message 4 (phone)|4|Message 3 (phone)|

Log2 - Computer:
|Time|Content|Lamport Clock|Previous Message|
|---|---|---|---|
|6:00 |Message 0|0|-|
|7:00 |Message 1|1|Message 0|
|10:00 |Message 2|2|Message 1|
|18:00 |Message 5 (pc)|3|Message 2|
|19:00 |Message 6 (pc)|4|Message 5 (pc)|
|20:00 |Message 7 (pc)|5|Message 6 (pc)|

## Merge Strategy using a "screw" Message
A "screw" message rewinds a log to a specific point in (lamport clock) time. It gets appended to a log and points to the previous message in the log, so it can be consistently verified by any client. 

1. Find the [common synchronization point](#Finding-the-common-synchronization-point) by providing hashes
2. Query all messages later than the common synchronization point
3. Set the lamport clock to max(own log clock, sync partner log clock)
4. Insert a screw message rewinding to the common synchronization point
5. Add messages from both logs in order of their lamport clock. Sort identical messages first by utc timestamp and when equal, by digest hash that would result if the message was applied.

Computers's perspective:
|Time|Content|Lamport Clock|Previous Message|
|---|---|---|---|
|6:00 |Message 0|0|-|
|7:00 |Message 1|1|Message 0|
|10:00 |Message 2|2|Message 1|
|18:00 |~~Message 5 (pc)~~|3|Message 2|
|19:00 |~~Message 6 (pc)~~|4|Message 5 (pc)|
|20:00 |~~Message 7 (pc)~~|5|Message 6 (pc)|
|-|Screw up to 2|6|Message 7 (pc)|
|11:00 |Message 3 (phone)|7|Message 2|
|18:00 |Message 5 (pc)|8|Message 3 (phone)|
|18:30 |Message 4 (phone)|9|Message 5 (pc)|
|19:00 |Message 6 (pc)|10|Message 4 (phone)|
|20:00 |Message 7 (pc)|11|Message 6 (pc)|

Phones's perspective:
|Time|Content|Lamport Clock|Previous Message|
|---|---|---|---|
|6:00 |Message 0|0|-|
|7:00 |Message 1|1|Message 0|
|10:00 |Message 2|2|Message 1|
|11:00 |~~Message 3 (phone)~~|3|Message 2|
|18:30 |~~Message 4 (phone)~~|4|Message 3 (phone)|
|-|Screw up to 2|6|Message 7 (pc)|
|11:00 |Message 3 (phone)|7|Message 2|
|18:00 |Message 5 (pc)|9|Message 3 (phone)|
|18:30 |Message 4 (phone)|9|Message 5 (pc)|
|19:00 |Message 6 (pc)|10|Message 4 (phone)|
|20:00 |Message 7 (pc)|11|Message 6 (pc)|

### Finding the common synchronization point
Perform some kind of distributed binary search:
1. in the first message to the synchronization peer, provide the last hash of the log, the hash of the message with floor(lamport_clock/2), the hash of the message with floor(lamport_clock 3/4),...
2. the peer responds with hashes in the inverval of the newest common hash and the next hash provided in the message before
3. after a few roundtrips, the common sync point is known or the peer decides that the interval of the common sync point is small enough so that it can send all new messages without a lot of overhead messages which are already known to the other peer

### Different approach: finding the common synchronization point using vector clocks instead of lamport clocks and hashes?
to be evaluated

## Other projects
* [Scuttlebutt -  unforgeable append-only message feeds](https://ssbc.github.io/ssb-db/)