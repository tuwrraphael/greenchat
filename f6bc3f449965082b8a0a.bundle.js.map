{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/first-time-init.html","webpack:///./src/components/home.html","webpack:///./src/components/link-device.html","webpack:///./node_modules/route-it/dist/index.js","webpack:///./node_modules/idb/build/esm/wrap-idb-value.js","webpack:///./node_modules/idb/build/esm/index.js","webpack:///./node_modules/idb/build/esm/async-iterators.js","webpack:///./src/append-only-log/LogMessage.ts","webpack:///./src/database/GreenchatDatabase.ts","webpack:///./src/components/first-time-init.ts","webpack:///./src/components/home.ts","webpack:///./src/models/DeviceLinkStatus.ts","webpack:///./src/routing/GreenchatRouteResolver.ts","webpack:///./src/message-encoding/MessageTypes.ts","webpack:///./src/state/actions/NotesActionCreator.ts","webpack:///./src/message-encoding/MessageModifier.ts","webpack:///./src/components/link-device.ts","webpack:///./src/state/Store.ts","webpack:///./src/state/lib/BaseStore.ts","webpack:///./src/state/actions/InitializationActionCreator.ts","webpack:///./src/utils/toBase64UrlSafe.ts","webpack:///./src/append-only-log/LocalAppendOnlyLog.ts","webpack:///./src/append-only-log/digestMessage.ts","webpack:///./src/append-only-log/LocalAppendOnlyLogService.ts","webpack:///./src/message-encoding/MessageEncoder.ts","webpack:///./src/state/actions/RoutingActionCreator.ts","webpack:///./src/state/reducers/NotesReducer.ts","webpack:///./src/ServiceLocator.ts","webpack:///./src/utils/uuid.ts","webpack:///./src/webrtc/config.ts","webpack:///./src/webrtc/PeerConnectionHandler.ts","webpack:///./src/webrtc/SignallingClient.ts","webpack:///./src/state/actions/SignallingActionCreator.ts","webpack:///./src/state/actions/DeviceLinkActionCreator.ts","webpack:///./src/state/reducers/GlobalReducer.ts","webpack:///./src/state/reducers/DeviceLinkReducer.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","e","this","routeResolver","routeRenderer","lastRoute","popStateListener","handlePopState","doRouting","window","location","pathname","document","querySelector","basePrefix","getAttribute","baseHref","href","addEventListener","removeEventListener","getRoute","resolve","render","substr","length","substring","URL","history","pushState","title","currentComponent","body","removeChild","appendChild","instanceOfAny","constructors","some","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","wrap","set","has","replaceTraps","callback","wrapFunction","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","storeNames","tx","sort","transformCachableValue","done","Promise","reject","unlisten","complete","error","DOMException","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","returnVal","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","asyncIterator","LogMessage","content","hash","previous","signature","timestamp","sequence","logId","log","db","privateKey","publicKey","last","msgData","messages","storeObj","add","put","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","indexOf","deleteObjectStore","createObjectStore","keyPath","createIndex","id","item","HTMLElement","super","innerHTML","customElements","define","serviceLocator","notesActionCreator","routingActionCreator","list","noteContent","takeNote","querySelectorAll","forEach","ev","preventDefault","navigate","subscription","subscribe","state","applyStoreState","note","notes","li","createElement","innerText","DeviceLinkStatus","Paths","MessageTypes","NotesActionNames","MessageModifier","deviceLinkActionCreator","invitePane","processStartPane","generateButton","pasteButton","invCode","pastedCode","style","display","startDeviceLinking","linkDevice","deviceLink","inviteCode","deviceLinkStatus","Uninitialized","currentRoute","router","FirstTimeInit","LinkDevice","component","addServices","initState","subscriptions","reducerSubscriptions","area","sub","push","splice","reducer","action","updatedAreas","applyUpdateFn","cb","onDispatch","TakeNote","type","NotesActionCreator","localAppendOnlyLogService","messageEncoder","appendOnlyLog","addMessage","encodeNote","dispatch","appendOnlyLogCreated","entry","getAll","msg","JSON","parse","TextDecoder","decode","Uint8Array","subarray","Note","navigateFirstTimeInit","navigateHome","toBase64UrlSafe","b","uint8Array","end","byteLength","btoa","String","fromCharCode","signingKey","persistence","createLogMessage","getPreviousHash","storeMessages","getLastMessage","previousHash","Date","encoded","beforeHash","TextEncoder","encode","uint8ArrayView","mergedArray","encodedContent","digest","crypto","subtle","digestMessage","sign","hasAppendOnlyLog","keyPair","generateKey","namedCurve","createAppendOnlyLog","localAppendOnlyLog","encodePublicKeyMessage","getAppendOnlyLog","PublicKey","stringify","res","DataView","buffer","setInt32","Public","Home","path","updateStore","ServiceLocator","uuid","getRandomValues","toString","iceConfig","iceServers","EventTarget","connectionId","signallingClient","candidate","rtcConnection","addIceCandidate","answer","setRemoteDescription","resolveInit","offer","resolveConnectionRequest","reason","rejectConnectionRequest","dispatchEvent","Event","channel","timeout","RTCPeerConnection","dataChannel","createDataChannel","onopen","onDataChannelOpen","onicecandidate","publishIceCandidate","createOffer","initiateConnection","setLocalDescription","resolved","setTimeout","close","ondatachannel","datachannel","requestConnection","createAnswer","sendAnswer","rejectConenctionRequest","localId","handlers","self","socket","WebSocket","send","onerror","console","onclose","connect","onmessage","parsed","data","find","v","acknowledgeInit","setOffer","setAnswer","handler","initiateChannel","connectionHandler","openChannel","SignallingActionNames","DeviceLinkActionNames","SignallingConnectionChanged","connected","SignallingActionCreator","signallingConnected","DeviceLinkChannelInitialized","DeviceLinkStatusChanged","status","deviceLinkChannel","initializeDeviceLinkChannel","openDeviceLinkChannel","err","Error","Started","addReducer","initializationActionCreator","signallingActionCreator","setServiceLocator","initialize","run","initializeApplication","startSignalling"],"mappings":"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","file":"f6bc3f449965082b8a0a.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","// Module\nvar code = \"<div> <h1> Welcome to greenchat! </h1> <p>Your device is being prepared, please hold on.</p> </div>\";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h1>Greenchat Home</h1> <nav> <a href=link-device>Link Device</a> </nav> <h2>List of your notes</h2> <ol id=notes-list> </ol> <div> <p>Add a note</p> <div> <input type=text id=note-content /> </div> <div> <button type=button id=addNoteBtn>Add Note</button> </div> </div>\";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h1>Link another of your devices to this account</h1> <div id=process-start-pane> <p>On the first device generate device invite code: <button type=button id=generate>Start</button></p> <p> On the second device paste the invite code: </p><div> <input type=text id=pasted-code /> <button id=redeem-code>redeem code</button> </div> <p></p> </div> <div id=invite-code-pane> Invite-Code: <span id=inv-code></span> </div>\";\n// Exports\nmodule.exports = code;","class t{constructor(t,e){this.routeResolver=t,this.routeRenderer=e,this.lastRoute=null,this.popStateListener=this.handlePopState.bind(this)}handlePopState(t){this.doRouting(window.location.pathname)}run(){let t=document.querySelector(\"base\");this.basePrefix=t.getAttribute(\"href\"),this.baseHref=t.href,window.addEventListener(\"popstate\",this.popStateListener),this.doRouting(window.location.pathname)}destroy(){window.removeEventListener(\"popstate\",this.popStateListener)}doRouting(t){let e=this.getRoute(t),n=this.routeResolver.resolve(this.lastRoute,e,this);return!!n&&(this.routeRenderer.render(n),this.lastRoute=e,!0)}getRoute(t){let e=t===this.baseHref,n=t.substr(0,this.basePrefix.length)===this.basePrefix;return e?\"/\":n?t.substring(this.basePrefix.length):t}navigate(t,e){let n=new URL(t,this.baseHref);this.doRouting(n.pathname)&&window.history.pushState({},e||document.title,n.href)}}class e{constructor(){this.currentComponent=null}render(t){t&&(this.currentComponent&&document.body.removeChild(this.currentComponent),document.body.appendChild(t),this.currentComponent=t)}}class n{constructor(t){this.container=t,this.currentComponent=!1}render(t){t&&(this.currentComponent&&(this.container.innerHTML=\"\"),this.container.appendChild(t),this.currentComponent=!0)}}export{e as BodyChildRouteRenderer,n as ContainerRouteRenderer,t as Router};\n//# sourceMappingURL=index.js.map\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { r as replaceTraps, i as instanceOfAny, a as reverseTransformCache, u as unwrap } from './wrap-idb-value.js';\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n","export class LogMessage {\n    constructor(public content: ArrayBuffer,\n        public hash: string,\n        public previous: string,\n        public signature: string,\n        public timestamp: number,\n        public sequence: number) {\n    }\n}\n","import \"idb/with-async-ittr\";\nimport { openDB, IDBPDatabase } from \"idb\";\nimport { LogPersistence } from \"../append-only-log/LogPersistence\";\nimport { LogMessage } from \"../append-only-log/LogMessage\";\nimport { AppendOnlyLogMetadata } from \"../append-only-log/AppendOnlyLogMetadata\";\n\nconst AppendOnlyLogMessages = \"AppendOnlyLogMessages\";\nconst AppendOnlyLogs = \"AppendOnlyLogs\";\n\nexport class GreenchatDatabase implements LogPersistence {\n    async getAppendOnlyLog(logId: string): Promise<AppendOnlyLogMetadata> {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        return {\n            logId: logId,\n            privateKey: log.privateKey,\n            publicKey: log.publicKey,\n            sequence: log.sequence\n        };\n    }\n    async getLastMessage(logId: string): Promise<LogMessage> {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        if (null == log.last) {\n            return null;\n        }\n        let msgData = await this.db.get(AppendOnlyLogMessages, log.last);\n        return new LogMessage(msgData.content, msgData.hash, msgData.previous, msgData.signature, msgData.timestamp, msgData.sequence);\n    }\n    async storeMessages(logId: string, messages: LogMessage[]): Promise<boolean> {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        const tx = this.db.transaction(AppendOnlyLogMessages, \"readwrite\");\n        let { last } = log;\n        let sequence = null;\n        for (let m of messages) {\n            let storeObj = { ...m, logId, previous: last };\n            await tx.store.add(storeObj);\n            last = storeObj.hash;\n            sequence = storeObj.sequence;\n        }\n        await tx.done;\n        log.last = last;\n        log.sequence = sequence;\n        await this.db.put(AppendOnlyLogs, log);\n        return true;\n    }\n    db: IDBPDatabase<unknown>;\n    async initialize() {\n        this.db = await openDB(\"greenchat-dbv2\", 2, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if ([1, 2].indexOf(oldVersion) > -1 && [2, 3].indexOf(newVersion) > -1) {\n                    db.deleteObjectStore(AppendOnlyLogMessages);\n                    db.deleteObjectStore(AppendOnlyLogs);\n                }\n                let store = db.createObjectStore(AppendOnlyLogMessages, { keyPath: [\"logId\", \"hash\"] });\n                store.createIndex(\"logId\", \"logId\");\n                db.createObjectStore(AppendOnlyLogs, { keyPath: \"id\" });\n            },\n        });\n    }\n    async hasAppendOnlyLog(logId: string) {\n        return !! await this.db.get(AppendOnlyLogs, logId);\n    }\n    async createAppendOnlyLog(logId: string, publicKey: CryptoKey, privateKey: CryptoKey) {\n        await this.db.add(AppendOnlyLogs, { id: logId, privateKey, publicKey, sequence: 0, last: null });\n    }\n    async addMessage(logId: string, m: LogMessage) {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        let storeObj = { ...m, logId };\n        await this.db.add(AppendOnlyLogMessages, storeObj);\n        log.last = storeObj.hash;\n        log.sequence = storeObj.sequence;\n        await this.db.put(AppendOnlyLogs, log);\n    }\n\n    async *getAll(logId: string): AsyncGenerator<LogMessage, void, unknown> {\n        const index = this.db.transaction(AppendOnlyLogMessages).store.index('logId');\n        for await (const cursor of index.iterate(logId)) {\n            let item = cursor.value;\n            yield new LogMessage(item.content, item.hash, item.previous, item.signature, item.timestamp,\n                item.sequence);\n        }\n    }\n}\n","import template from \"./first-time-init.html\";\n\nexport class FirstTimeInit extends HTMLElement {\n\n    constructor() {\n        super();\n        this.innerHTML = template;\n    }\n\n    connectedCallback() {\n\n    }\n}\n\ncustomElements.define('app-first-time-init', FirstTimeInit);","import template from \"./home.html\";\nimport { Store } from \"../state/Store\";\nimport { NotesActionCreator } from \"../state/actions/NotesActionCreator\";\nimport { ServiceLocator } from \"../ServiceLocator\";\nimport { RoutingActionCreator } from \"../state/actions/RoutingActionCreator\";\nimport { State } from \"../state/State\";\n\nexport class Home extends HTMLElement {\n    store: Store;\n    notesActionCreator: NotesActionCreator;\n    list: HTMLOListElement;\n    noteContent: HTMLInputElement;\n    subscription: () => void;\n    routingActionCreator: RoutingActionCreator;\n\n    constructor() {\n        super();\n        this.innerHTML = template;\n    }\n\n    addServices(serviceLocator: ServiceLocator) {\n        this.store = serviceLocator.store;\n        this.notesActionCreator = serviceLocator.notesActionCreator;\n        this.routingActionCreator = serviceLocator.routingActionCreator;\n    }\n\n    connectedCallback() {\n        let element = this;\n        this.list = element.querySelector(\"#notes-list\");\n        this.noteContent = element.querySelector(\"#note-content\");\n        element.querySelector(\"#addNoteBtn\").addEventListener(\"click\", () => {\n            this.notesActionCreator.takeNote(this.noteContent.value);\n            this.noteContent.value = \"\";\n        })\n        element.querySelectorAll(\"a\").forEach(e => {\n            e.addEventListener(\"click\", ev => {\n                ev.preventDefault();\n                this.routingActionCreator.navigate(e.getAttribute(\"href\"))\n            });\n        });\n        this.subscription = this.store.subscribe(\"notes\", state => this.applyStoreState(state));\n        this.applyStoreState(this.store.state);\n    }\n\n    private applyStoreState(state: State) {\n        this.list.innerHTML = \"\";\n        for (let note of state.notes.notes) {\n            let li = document.createElement(\"li\");\n            li.innerText = note;\n            this.list.appendChild(li);\n        }\n    }\n\n    disconnectedCallback() {\n        this.subscription();\n    }\n}\n\ncustomElements.define('app-home', Home);","export enum DeviceLinkStatus {\n    Started,\n    Succeeded,\n    Error,\n    Uninitialized\n}\n","import { Router } from \"route-it\";\nimport { FirstTimeInit } from \"../components/first-time-init\";\nimport { Home } from \"../components/home\";\nimport { Store } from \"../state/Store\";\nimport { NotesActionCreator } from \"../state/actions/NotesActionCreator\";\nimport { ServiceLocator } from \"../ServiceLocator\";\nimport { LinkDevice } from \"../components/link-device\";\n\nexport enum Paths {\n    FirstTimeInit = \"first-time-init\",\n    LinkDevice = \"link-device\",\n    Home = \"\"\n}\n\nexport class GreenchatRouteResolver {\n    serviceLocator: ServiceLocator;\n    setServiceLocator(serviceLocator: ServiceLocator) {\n        this.serviceLocator = serviceLocator;\n    }\n\n    resolve(lastRoute: string, currentRoute: string, router: Router<HTMLElement>) {\n        switch (currentRoute) {\n            case Paths.FirstTimeInit:\n                return new FirstTimeInit();\n            case Paths.LinkDevice: {\n                let component = new LinkDevice();\n                component.addServices(this.serviceLocator);\n                return component;\n            }\n            default:\n                let component = new Home();\n                component.addServices(this.serviceLocator);\n                return component;\n        }\n    }\n}\n","export enum MessageTypes {\n    PublicKey = \"PublicKey\",\n    Note = \"Note\"\n}\n","import { Store } from \"../Store\";\nimport { Action } from \"../lib/Action\";\nimport { LocalAppendOnlyLogService } from \"../../append-only-log/LocalAppendOnlyLogService\";\nimport { MessageEncoder } from \"../../message-encoding/MessageEncoder\";\n\nexport enum NotesActionNames {\n    TakeNote = \"TakeNote\"\n}\n\nexport class TakeNote implements Action {\n    readonly type = NotesActionNames.TakeNote;\n    constructor(public content: string) {\n\n    }\n}\n\nexport type NotesActions = TakeNote;\n\nexport class NotesActionCreator {\n    constructor(private store: Store,\n         private localAppendOnlyLogService : LocalAppendOnlyLogService,\n         private messageEncoder : MessageEncoder) {\n\n    }\n    async takeNote(content: string) {\n        let appendOnlyLog = await this.localAppendOnlyLogService.get(\"local\");\n        await appendOnlyLog.addMessage(this.messageEncoder.encodeNote(content));\n        this.store.dispatch(new TakeNote(content));\n    }\n}","export enum MessageModifier {\n    Public = 1\n}\n","import template from \"./link-device.html\";\nimport { Store } from \"../state/Store\";\nimport { ServiceLocator } from \"../ServiceLocator\";\nimport { DeviceLinkActionCreator } from \"../state/actions/DeviceLinkActionCreator\";\nimport { DeviceLinkStatus } from \"../models/DeviceLinkStatus\";\nimport { State } from \"../state/State\";\n\nexport class LinkDevice extends HTMLElement {\n    store: Store;\n    deviceLinkActionCreator: DeviceLinkActionCreator;\n    invitePane: HTMLDivElement;\n    processStartPane: HTMLDivElement;\n    generateButton: HTMLButtonElement;\n    pasteButton: HTMLButtonElement;\n    invCode: HTMLSpanElement;\n    pastedCode: HTMLInputElement;\n    subscription: () => void;\n\n    constructor() {\n        super();\n        this.innerHTML = template;\n    }\n\n    addServices(serviceLocator: ServiceLocator) {\n        this.store = serviceLocator.store;\n        this.deviceLinkActionCreator = serviceLocator.deviceLinkActionCreator;\n    }\n\n    connectedCallback() {\n        let element = this;\n        this.invitePane = element.querySelector(\"#invite-code-pane\");\n        this.processStartPane = element.querySelector(\"#process-start-pane\");\n        this.generateButton = element.querySelector(\"#generate\");\n        this.pasteButton = element.querySelector(\"#redeem-code\");\n        this.invCode = element.querySelector(\"#inv-code\");\n        this.pastedCode = element.querySelector(\"#pasted-code\");\n        this.invitePane.style.display = \"none\";\n\n        this.generateButton.addEventListener(\"click\", async () => {\n            await this.deviceLinkActionCreator.startDeviceLinking();\n        });\n\n        this.pasteButton.addEventListener(\"click\", async () => {\n            await this.deviceLinkActionCreator.linkDevice(this.pastedCode.value);\n        });\n\n        this.subscription = this.store.subscribe(\"deviceLink\", state => this.applyStoreState(state));\n        this.applyStoreState(this.store.state);\n    }\n\n    private applyStoreState(state : State) {\n        this.invitePane.style.display = state.deviceLink.inviteCode ? \"block\" : \"none\";\n            this.invCode.innerText = state.deviceLink.inviteCode;\n            this.processStartPane.style.display = state.deviceLink.deviceLinkStatus == DeviceLinkStatus.Uninitialized ? \"block\" : \"none\";\n    }\n\n    disconnectedCallback() {\n        this.subscription();\n    }\n}\n\ncustomElements.define('app-link-device', LinkDevice);\n","import { State } from \"./State\";\nimport { BaseStore } from \"./lib/BaseStore\";\n\nexport class Store extends BaseStore<State> {\n    \n};","import { Reducer } from \"./Reducer\";\nimport { Action } from \"./Action\";\n\ninterface Subscription<TState> {\n    call(a: TState): void;\n    area: keyof TState | \"\";\n}\n\ninterface ReducerSubscription<TState> {\n    reducer: Reducer<any, any>;\n    area: keyof TState | null;\n}\n\nexport class BaseStore<TState> {\n    public state: TState;\n    private subscriptions: Subscription<TState>[];\n    private reducerSubscriptions: ReducerSubscription<TState>[];\n    constructor(initState: () => TState) {\n        this.subscriptions = [];\n        this.reducerSubscriptions = [];\n        this.state = initState();\n    }\n    subscribe(area: keyof TState, call: (a: TState) => void) {\n        let sub = { area, call };\n        this.subscriptions.push(sub);\n        return () => {\n            this.subscriptions.splice(this.subscriptions.indexOf(sub), 1);\n        };\n    }\n    addReducer<K extends keyof TState>(area: K | null, reducer: Reducer<TState[K] | TState, any>) {\n        this.reducerSubscriptions.push({ area, reducer });\n    }\n    dispatch(action: Action) {\n        let updatedAreas: (keyof TState | \"\")[] = [];\n        for (let s of this.reducerSubscriptions) {\n            let applyUpdateFn;\n            if (s.area) {\n                applyUpdateFn = (cb: (a: any) => any) => {\n                    (<any>this.state[s.area]) = cb(this.state[s.area]);\n                    updatedAreas.push(s.area);\n                };\n            }\n            else {\n                applyUpdateFn = (cb: (a: any) => any) => {\n                    this.state = cb(this.state);\n                    updatedAreas.push(\"\");\n                };\n            }\n            s.reducer.onDispatch(action, applyUpdateFn);\n        }\n        if (updatedAreas.length) {\n            for (let s of this.subscriptions) {\n                if (!s.area || updatedAreas.indexOf(s.area) > -1) {\n                    s.call(this.state);\n                }\n            }\n        }\n    }\n}\n","import { RoutingActionCreator } from \"./RoutingActionCreator\";\nimport { LocalAppendOnlyLogService } from \"../../append-only-log/LocalAppendOnlyLogService\";\nimport { Store } from \"../Store\";\nimport { MessageTypes } from \"../../message-encoding/MessageTypes\";\nimport { TakeNote } from \"./NotesActionCreator\";\nexport class InitializationActionCreator {\n    constructor(private store: Store, private localAppendOnlyLogService: LocalAppendOnlyLogService, private routingActionCreator: RoutingActionCreator) {\n    }\n    async initializeApplication() {\n        let appendOnlyLogCreated = await this.localAppendOnlyLogService.appendOnlyLogCreated(\"local\");\n        if (!appendOnlyLogCreated) {\n            this.routingActionCreator.navigateFirstTimeInit();\n            await this.localAppendOnlyLogService.create(\"local\");\n            this.routingActionCreator.navigateHome();\n        } else {\n            let log = await this.localAppendOnlyLogService.get(\"local\");\n            for await (let entry of log.getAll()) {\n                // for now assume public msg\n                let msg = JSON.parse(new TextDecoder().decode(new Uint8Array(entry.content).subarray(2)));\n                if (msg.type == MessageTypes.Note) {\n                    this.store.dispatch(new TakeNote(msg.content));\n                }\n            }\n        }\n    }\n}\n","export function toBase64UrlSafe(b: ArrayBuffer) {\n    let uint8Array = new Uint8Array(b);\n    let start = 0;\n    let end = uint8Array.byteLength;\n\n    const base64 = window.btoa(\n        String.fromCharCode.apply(null, uint8Array.subarray(start, end)));\n    return base64\n        .replace(/\\=/g, '') // eslint-disable-line no-useless-escape\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_');\n}","import { LogMessage } from \"./LogMessage\";\nimport { toBase64UrlSafe } from \"../utils/toBase64UrlSafe\";\nimport { digestMessage } from \"./digestMessage\";\nimport { LogPersistence } from \"./LogPersistence\";\nimport { MessageEncoder } from \"../message-encoding/MessageEncoder\";\nimport { RemoteAppendOnlyLog } from \"./RemoteAppendOnlyLog\";\n\nexport class LocalAppendOnlyLog {\n\n    constructor(private signingKey: CryptoKey,\n        private logId: string,\n        private sequence: number,\n        private persistence: LogPersistence,\n        private messageEncoder: MessageEncoder) {\n    }\n\n    async addMessage(content: ArrayBuffer) {\n        let sequence = this.sequence + 1;\n        let msg = await this.createLogMessage(content, await this.getPreviousHash(), sequence);\n        await this.persistence.storeMessages(this.logId, [msg]);\n        this.sequence = sequence;\n    }\n\n    async getPreviousHash() {\n        if (this.sequence == 0) {\n            return \"initial\";\n        }\n        else {\n            let last = await this.persistence.getLastMessage(this.logId);\n            return last.hash;\n        }\n    }\n\n    private async createLogMessage(content: ArrayBuffer, previousHash: string, sequence: number): Promise<LogMessage> {\n        let timestamp = +new Date();\n        let encoded = await digestMessage(previousHash, content, timestamp);\n        let signature = await crypto.subtle.sign({ name: \"ECDSA\", hash: \"SHA-256\" }, this.signingKey, encoded.encodedContent);\n        return new LogMessage(content, toBase64UrlSafe(encoded.digest), previousHash, toBase64UrlSafe(signature), timestamp, sequence);\n    }\n\n    getAll(): AsyncGenerator<LogMessage, void, unknown> {\n        return this.persistence.getAll(this.logId);\n    }    \n}","export async function digestMessage(beforeHash: string, content: ArrayBuffer, timestamp: number) {\n    let encoder = new TextEncoder();\n    let encoded = encoder.encode(`${timestamp}.${beforeHash}`);\n    let uint8ArrayView = new Uint8Array(content);\n    let mergedArray = new Uint8Array(encoded.length + uint8ArrayView.length);\n    mergedArray.set(encoded);\n    mergedArray.set(uint8ArrayView, encoded.length);\n    let digest = await crypto.subtle.digest(\"SHA-256\", encoded);\n    return {\n        encodedContent: encoded,\n        digest: digest\n    };\n}\n","import { LocalAppendOnlyLog } from \"./LocalAppendOnlyLog\";\nimport { MessageEncoder } from \"../message-encoding/MessageEncoder\";\nimport { LogPersistence } from \"./LogPersistence\";\n\nexport class LocalAppendOnlyLogService {\n    constructor(private persistence: LogPersistence, private messageEncoder: MessageEncoder) {\n    }\n    async appendOnlyLogCreated(logId: string) {\n        return await this.persistence.hasAppendOnlyLog(logId);\n    }\n    async create(logId: string) {\n        let keyPair = await crypto.subtle.generateKey({ name: \"ECDSA\", namedCurve: \"P-256\" }, false, [\"sign\", \"verify\"]);\n        await this.persistence.createAppendOnlyLog(logId, keyPair.publicKey, keyPair.privateKey);\n        let localAppendOnlyLog = new LocalAppendOnlyLog(keyPair.privateKey, \"local\", 0, this.persistence, this.messageEncoder);\n        await localAppendOnlyLog.addMessage(this.messageEncoder.encodePublicKeyMessage(keyPair.publicKey));\n    }\n    async get(logId: string) {\n        let appendOnlyLog = await this.persistence.getAppendOnlyLog(logId);\n        return new LocalAppendOnlyLog(appendOnlyLog.privateKey, logId, appendOnlyLog.sequence, this.persistence, this.messageEncoder);\n    }\n}\n","import { MessageTypes } from \"./MessageTypes\";\nimport { MessageModifier } from \"./MessageModifier\";\nexport class MessageEncoder {\n    encodePublicKeyMessage(publicKey: CryptoKey): ArrayBuffer {\n        let msg = { publicKey, type: MessageTypes.PublicKey };\n        let encoder = new TextEncoder();\n        let encoded = encoder.encode(JSON.stringify(msg));\n        let res = new Uint8Array(encoded.length + 2);\n        new DataView(res.buffer).setInt32(0, MessageModifier.Public, true);\n        res.set(encoded, 2);\n        return res.buffer;\n    }\n    encodeNote(content: string): ArrayBuffer {\n        let msg = { content, type: MessageTypes.Note };\n        let encoder = new TextEncoder();\n        let encoded = encoder.encode(JSON.stringify(msg));\n        let res = new Uint8Array(encoded.length + 2);\n        new DataView(res.buffer).setInt32(0, MessageModifier.Public, true);\n        res.set(encoded, 2);\n        return res.buffer;\n    }\n}\n","import { Router } from \"route-it\";\nimport { Paths } from \"../../routing/GreenchatRouteResolver\";\nexport class RoutingActionCreator {\n    constructor(private router: Router<HTMLElement>) {\n    }\n    navigateFirstTimeInit() {\n        this.router.navigate(Paths.FirstTimeInit, null);\n    }\n    navigateHome() {\n        this.router.navigate(Paths.Home, null);\n    }\n\n    navigate(path: string) {\n        this.router.navigate(path, null);\n    }\n}\n","import { Reducer } from \"../lib/Reducer\";\nimport { NotesSubState } from \"../State\";\nimport { NotesActions, NotesActionNames } from \"../actions/NotesActionCreator\";\n\nexport class NotesReducer implements Reducer<NotesSubState, NotesActions> {\n    onDispatch(action: NotesActions, updateStore: (a: (s: NotesSubState) => NotesSubState) => void): void {\n        switch (action.type) {\n            case NotesActionNames.TakeNote: {\n                updateStore((s: NotesSubState) => {\n                    let notes = s.notes || [];\n                    notes.push(action.content);\n                    return { ...s, notes };\n                })\n            }\n        }\n    }\n}","import { Store } from \"./state/Store\";\nimport { NotesActionCreator } from \"./state/actions/NotesActionCreator\";\nimport { DeviceLinkActionCreator } from \"./state/actions/DeviceLinkActionCreator\";\nimport { RoutingActionCreator } from \"./state/actions/RoutingActionCreator\";\n\nexport class ServiceLocator {\n    constructor(public store: Store,\n        public notesActionCreator: NotesActionCreator,\n        public deviceLinkActionCreator: DeviceLinkActionCreator,\n        public routingActionCreator : RoutingActionCreator) {\n\n    }\n}","export function uuid() {\n    return ((<string><unknown>[1e7]) + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n        (<number><unknown>c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> <number><unknown>c / 4).toString(16)\n    );\n}","export const iceConfig =  { iceServers: [{\"urls\":[\"turn:turn.greenchat.me:443\"],\"username\":\"raphael\",\"credential\":\"@123@test@\"}] };\nexport const signallingServer = \"wss://hub.greenchat.me\";","import { iceConfig } from \"./config\";\nimport { SignallingClient } from \"./SignallingClient\";\nimport { ChannelInitialization } from \"./ChannelInitialization\";\nimport { DataChannelOpenedEventInit } from \"./DataChannelOpenedEventInit\";\nexport class PeerConnectionHandler extends EventTarget {\n    private rtcConnection: RTCPeerConnection;\n    private resolveInit: () => void;\n    private resolveConnectionRequest: (offer: RTCSessionDescriptionInit) => void;\n    private rejectConnectionRequest: (reason: string) => void;\n    constructor(public connectionId: string, private signallingClient: SignallingClient) {\n        super();\n    }\n    addIceCandidate(candidate: RTCIceCandidateInit) {\n        this.rtcConnection.addIceCandidate(candidate);\n    }\n    setAnswer(answer: RTCSessionDescriptionInit) {\n        this.rtcConnection.setRemoteDescription(answer);\n    }\n    acknowledgeInit() {\n        this.resolveInit();\n    }\n    setOffer(offer: RTCSessionDescriptionInit) {\n        this.resolveConnectionRequest(offer);\n    }\n    rejectConenctionRequest(reason: string) {\n        this.rejectConnectionRequest(reason);\n    }\n    private onDataChannelOpen(c: RTCDataChannel) {\n        this.dispatchEvent(new Event(\"datachannelopen\", <DataChannelOpenedEventInit>{ channel: c }));\n    }\n    initiateChannel(timeout: number): Promise<unknown> {\n        this.rtcConnection = new RTCPeerConnection({ ...iceConfig });\n        let dataChannel = this.rtcConnection.createDataChannel(\"sendChannel\");\n        dataChannel.onopen = () => this.onDataChannelOpen(dataChannel);\n        this.rtcConnection.onicecandidate = ({ candidate }) => {\n            if (candidate) {\n                this.signallingClient.publishIceCandidate(this.connectionId, candidate);\n            }\n        };\n        this.rtcConnection.createOffer().then(offer => {\n            this.signallingClient.initiateConnection(this.connectionId, timeout, offer);\n            this.rtcConnection.setLocalDescription(offer);\n        });\n        let promise = new Promise<ChannelInitialization>((resolve, reject) => {\n            let resolved = false;\n            this.resolveInit = () => {\n                resolved = true;\n                resolve();\n            };\n            setTimeout(() => {\n                if (!resolved) {\n                    reject(\"Timeout\");\n                    this.rtcConnection.close();\n                }\n            }, 2000);\n        });\n        return promise;\n    }\n    openChannel(): Promise<unknown> {\n        this.rtcConnection = new RTCPeerConnection({ ...iceConfig });\n        this.rtcConnection.onicecandidate = ({ candidate }) => {\n            if (candidate) {\n                this.signallingClient.publishIceCandidate(this.connectionId, candidate);\n            }\n        };\n        this.rtcConnection.ondatachannel = e => {\n            let datachannel = e.channel;\n            datachannel.onopen = () => {\n                this.onDataChannelOpen(datachannel);\n            };\n        };\n        this.signallingClient.requestConnection(this.connectionId);\n        let promise = new Promise<unknown>((resolve, reject) => {\n            let resolved = false;\n            this.resolveConnectionRequest = (offer: RTCSessionDescriptionInit) => {\n                this.rtcConnection.setRemoteDescription(offer).then(() => {\n                    this.rtcConnection.createAnswer().then(answer => {\n                        this.rtcConnection.setLocalDescription(answer);\n                        this.signallingClient.sendAnswer(this.connectionId, answer);\n                        resolved = true;\n                        resolve();\n                    });\n                });\n            };\n            this.rejectConenctionRequest = (msg: string) => {\n                resolved = true;\n                reject(msg);\n                this.rtcConnection.close();\n            };\n            setTimeout(() => {\n                if (!resolved) {\n                    reject(\"Timeout\");\n                    this.rtcConnection.close();\n                }\n            }, 10000);\n        });\n        return promise;\n    }\n}\n","import { uuid } from \"../utils/uuid\";\nimport { signallingServer } from \"./config\";\nimport { PeerConnectionHandler } from \"./PeerConnectionHandler\";\nimport { ChannelInitialization } from \"./ChannelInitialization\";\n\nexport class SignallingClient extends EventTarget {\n    private localId: string;\n    private handlers: PeerConnectionHandler[];\n    private socket: WebSocket;\n\n    constructor() {\n        super();\n        this.localId = uuid();\n        this.handlers = [];\n    }\n\n    connect() {\n        let self = this;\n        let socket = this.socket = new WebSocket(signallingServer);\n        socket.onopen = function () {\n            socket.send(JSON.stringify({ type: \"connected\", id: self.localId }));\n            this.dispatchEvent(new Event(\"connected\"));\n        };\n        socket.onerror = function (error) {\n            console.log('WebSocket Error ' + error);\n            socket.close();\n        };\n        socket.onclose = function (e) {\n            console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);\n            this.dispatchEvent(new Event(\"disconnected\"));\n            setTimeout(function () {\n                self.connect();\n            }, 1000);\n        }\n        socket.onmessage = function (e) {\n            let parsed = JSON.parse(e.data);\n            switch (parsed.type) {\n                case \"connection_initialized\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId).acknowledgeInit();\n                    break;\n                case \"connection_offer\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .setOffer(parsed.offer);\n                    break;\n                case \"connection_accepted\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .setAnswer(parsed.answer);\n                    break;\n                case \"connection_not_found\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .rejectConenctionRequest(\"Not found\");\n                    break;\n                case \"new_ice_candidate\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .addIceCandidate(parsed.candidate);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    async initializeDeviceLinkChannel(timeout: number): Promise<ChannelInitialization> {\n        let handler = new PeerConnectionHandler(uuid(), this);\n        this.handlers.push(handler);\n        await handler.initiateChannel(timeout);\n        return {\n            connectionHandler: handler\n        };\n    }\n\n    async openDeviceLinkChannel(connectionId: string): Promise<ChannelInitialization> {\n        let handler = new PeerConnectionHandler(connectionId, this);\n        this.handlers.push(handler);\n        await handler.openChannel();\n        return {\n            connectionHandler: handler\n        };\n    }\n    requestConnection(connectionId: string) {\n        this.socket.send(JSON.stringify({ type: \"request_connection\", connectionId }));\n    }\n\n    sendAnswer(connectionId: string, answer: RTCSessionDescriptionInit) {\n        this.socket.send(JSON.stringify({ type: \"accept_connection\", connectionId, answer }));\n    }\n\n    initiateConnection(connectionId: string, timeout: number, offer: RTCSessionDescriptionInit) {\n        this.socket.send(JSON.stringify({ type: \"initialize_connection\", connectionId, timeout, offer }));\n    }\n\n    publishIceCandidate(connectionId: string, candidate: RTCIceCandidateInit) {\n        this.socket.send(JSON.stringify({\n            type: \"new_ice_candidate\",\n            candidate,\n            id: this.localId,\n            connectionId: connectionId\n        }));\n    }\n}","import { Store } from \"../Store\";\nimport { Action } from \"../lib/Action\";\nimport { SignallingClient } from \"../../webrtc/SignallingClient\";\n\nexport enum SignallingActionNames {\n    SignallingConnectionChanged = \"SignallingConnectionChanged\"\n}\n\nexport class SignallingConnectionChanged implements Action {\n    readonly type = SignallingActionNames.SignallingConnectionChanged;\n    constructor(public connected: boolean) {\n\n    }\n}\n\nexport type SignallingActions = SignallingConnectionChanged;\n\nexport class SignallingActionCreator {\n    constructor(private store: Store, private signallingClient: SignallingClient) {\n        this.signallingClient.addEventListener(\"connected\", () => {\n            this.store.dispatch(new SignallingConnectionChanged(true));\n        });\n        this.signallingClient.addEventListener(\"disconnected\", () => {\n            this.store.dispatch(new SignallingConnectionChanged(false));\n        });\n    }\n\n    startSignalling() {\n        this.signallingClient.connect();\n    }\n}","import { Store } from \"../Store\";\nimport { Action } from \"../lib/Action\";\nimport { SignallingClient } from \"../../webrtc/SignallingClient\";\nimport { DeviceLinkStatus } from \"../../models/DeviceLinkStatus\";\n\nexport enum DeviceLinkActionNames {\n    DeviceLinkChannelInitialized = \"DeviceLinkChannelInitialized\",\n    DeviceLinkStatusChanged = \"DeviceLinkStatusChanged\"\n}\n\nexport class DeviceLinkChannelInitialized implements Action {\n    readonly type = DeviceLinkActionNames.DeviceLinkChannelInitialized;\n    constructor(public connectionId: string) {\n\n    }\n}\n\nexport class DeviceLinkStatusChanged implements Action {\n    readonly type = DeviceLinkActionNames.DeviceLinkStatusChanged;\n    constructor(public status: DeviceLinkStatus) {\n\n    }\n}\n\nexport type DeviceLinkActions = DeviceLinkChannelInitialized | DeviceLinkStatusChanged;\n\nexport class DeviceLinkActionCreator {\n    constructor(private store: Store, private signallingClient: SignallingClient) {\n    }\n\n    async startDeviceLinking() {\n        let deviceLinkChannel = await this.signallingClient.initializeDeviceLinkChannel(120000);\n        deviceLinkChannel.connectionHandler.addEventListener(\"datachannelopen\", e => {\n            console.log(\"connected\");\n        });\n        this.store.dispatch(new DeviceLinkChannelInitialized(deviceLinkChannel.connectionHandler.connectionId));\n    }\n\n    async linkDevice(connectionId: string) {\n        try {\n            let deviceLinkChannel = await this.signallingClient.openDeviceLinkChannel(connectionId);\n            deviceLinkChannel.connectionHandler.addEventListener(\"datachannelopen\", e => {\n                console.log(\"connected\");\n            });\n        }\n        catch (err) {\n            this.store.dispatch(new DeviceLinkStatusChanged(DeviceLinkStatus.Error));\n        }\n    }\n}","import { Reducer } from \"../lib/Reducer\";\nimport { State } from \"../State\";\nimport { SignallingActions, SignallingActionNames } from \"../actions/SignallingActionCreator\";\n\nexport class GlobalReducer implements Reducer<State, SignallingActions> {\n    onDispatch(action: SignallingActions, updateStore: (a: (s: State) => State) => void): void {\n        switch (action.type) {\n            case SignallingActionNames.SignallingConnectionChanged: {\n                updateStore(s => {\n                    return { ...s, signallingConnected: action.connected };\n                })\n            }\n        }\n    }\n}","import { Reducer } from \"../lib/Reducer\";\nimport { DeviceLinkState } from \"../State\";\nimport { DeviceLinkActions, DeviceLinkActionNames } from \"../actions/DeviceLinkActionCreator\";\nimport { DeviceLinkStatus } from \"../../models/DeviceLinkStatus\";\n\nexport class DeviceLinkReducer implements Reducer<DeviceLinkState, DeviceLinkActions> {\n    onDispatch(action: DeviceLinkActions, updateStore: (a: (s: DeviceLinkState) => DeviceLinkState) => void): void {\n        switch (action.type) {\n            case DeviceLinkActionNames.DeviceLinkChannelInitialized:\n                updateStore((s) => {\n                    return {\n                        ...s, inviteCode: action.connectionId,\n                        deviceLinkStatus: DeviceLinkStatus.Started\n                    };\n                });\n                break;\n            case DeviceLinkActionNames.DeviceLinkStatusChanged:\n                updateStore((s) => {\n                    return {\n                        ...s,\n                        deviceLinkStatus: action.status\n                    };\n                });\n                break;\n        }\n    }\n}","import { Router, BodyChildRouteRenderer } from \"route-it\";\nimport { GreenchatDatabase } from \"./database/GreenchatDatabase\";\nimport { GreenchatRouteResolver } from \"./routing/GreenchatRouteResolver\";\nimport { Store } from \"./state/Store\";\nimport { InitializationActionCreator } from \"./state/actions/InitializationActionCreator\";\nimport { LocalAppendOnlyLogService } from \"./append-only-log/LocalAppendOnlyLogService\";\nimport { MessageEncoder } from \"./message-encoding/MessageEncoder\";\nimport { RoutingActionCreator } from \"./state/actions/RoutingActionCreator\";\nimport { NotesReducer } from \"./state/reducers/NotesReducer\";\nimport { NotesActionCreator } from \"./state/actions/NotesActionCreator\";\nimport { ServiceLocator } from \"./ServiceLocator\";\nimport { SignallingClient } from \"./webrtc/SignallingClient\";\nimport { GlobalReducer } from \"./state/reducers/GlobalReducer\";\nimport { SignallingActionCreator } from \"./state/actions/SignallingActionCreator\";\nimport { DeviceLinkActionCreator } from \"./state/actions/DeviceLinkActionCreator\";\nimport { DeviceLinkStatus } from \"./models/DeviceLinkStatus\";\nimport { DeviceLinkReducer } from \"./state/reducers/DeviceLinkReducer\";\n\nasync function run() {\n    const db = new GreenchatDatabase();\n    const signallingClient = new SignallingClient();\n    const routeResolver = new GreenchatRouteResolver();\n    const router = new Router(routeResolver, new BodyChildRouteRenderer());\n    const store = new Store(() => {\n        return {\n            signallingConnected: false,\n            notes: { notes: [] },\n            deviceLink: {\n                deviceLinkStatus: DeviceLinkStatus.Uninitialized,\n                inviteCode: null\n            }\n        }\n    });\n    store.addReducer(\"notes\", new NotesReducer());\n    store.addReducer(null, new GlobalReducer());\n    store.addReducer(\"deviceLink\", new DeviceLinkReducer());\n\n    const messageEncoder = new MessageEncoder();\n    const localAppendOnlyLogService = new LocalAppendOnlyLogService(db, messageEncoder);\n\n    const routingActionCreator = new RoutingActionCreator(router);\n    const initializationActionCreator = new InitializationActionCreator(store, localAppendOnlyLogService, routingActionCreator);\n    const notesActionCreator = new NotesActionCreator(store, localAppendOnlyLogService, messageEncoder);\n    const signallingActionCreator = new SignallingActionCreator(store, signallingClient);\n    const deviceLinkActionCreator = new DeviceLinkActionCreator(store, signallingClient);\n\n    const serviceLocator = new ServiceLocator(store,\n        notesActionCreator,\n        deviceLinkActionCreator,\n        routingActionCreator);\n    routeResolver.setServiceLocator(serviceLocator);\n\n    await db.initialize();\n    router.run();\n\n    await initializationActionCreator.initializeApplication();\n    signallingActionCreator.startSignalling();\n}\n\nrun().catch(err => console.error(err));\n\n"],"sourceRoot":""}