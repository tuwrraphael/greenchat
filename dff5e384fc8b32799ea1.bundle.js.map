{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/first-time-init.html","webpack:///./src/components/home.html","webpack:///./src/components/link-device.html","webpack:///./node_modules/route-it/dist/index.js","webpack:///./node_modules/idb/build/esm/wrap-idb-value.js","webpack:///./node_modules/idb/build/esm/index.js","webpack:///./node_modules/idb/build/esm/async-iterators.js","webpack:///./src/append-only-log/LogMessage.ts","webpack:///./src/utils/uuid.ts","webpack:///./src/database/GreenchatDatabase.ts","webpack:///./src/components/first-time-init.ts","webpack:///./src/components/home.ts","webpack:///./src/models/DeviceLinkStatus.ts","webpack:///./src/routing/GreenchatRouteResolver.ts","webpack:///./src/message-encoding/MessageTypes.ts","webpack:///./src/components/link-device.ts","webpack:///./src/state/Store.ts","webpack:///./src/state/lib/BaseStore.ts","webpack:///./src/state/actions/NotesActionCreator.ts","webpack:///./src/state/actions/InitializationActionCreator.ts","webpack:///./src/utils/toBase64UrlSafe.ts","webpack:///./src/append-only-log/LocalAppendOnlyLog.ts","webpack:///./src/append-only-log/digestMessage.ts","webpack:///./src/message-encoding/MessageModifier.ts","webpack:///./src/append-only-log/LocalAppendOnlyLogService.ts","webpack:///./src/message-encoding/MessageEncoder.ts","webpack:///./src/state/actions/RoutingActionCreator.ts","webpack:///./src/state/reducers/NotesReducer.ts","webpack:///./src/ServiceLocator.ts","webpack:///./src/webrtc/config.ts","webpack:///./src/webrtc/PeerConnectionHandler.ts","webpack:///./src/state/actions/SignallingActionCreator.ts","webpack:///./src/webrtc/SignallingClient.ts","webpack:///./src/state/reducers/GlobalReducer.ts","webpack:///./src/state/actions/DeviceLinkActionCreator.ts","webpack:///./src/state/reducers/DeviceLinkReducer.ts","webpack:///./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","e","this","routeResolver","routeRenderer","lastRoute","popStateListener","handlePopState","doRouting","window","location","pathname","document","querySelector","basePrefix","getAttribute","baseHref","href","addEventListener","removeEventListener","getRoute","resolve","render","substr","length","substring","URL","history","pushState","title","currentComponent","body","removeChild","appendChild","instanceOfAny","constructors","some","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","wrap","set","has","replaceTraps","callback","wrapFunction","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","storeNames","tx","sort","transformCachableValue","done","Promise","reject","unlisten","complete","error","DOMException","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","IDBRequest","request","promise","success","result","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","returnVal","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","asyncIterator","LogMessage","content","hash","last","signature","timestamp","sequence","uuid","crypto","getRandomValues","Uint8Array","toString","logId","log","db","privateKey","publicKey","top","msgData","messages","storeObj","id","before","add","put","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","createObjectStore","keyPath","createIndex","item","HTMLElement","super","innerHTML","customElements","define","serviceLocator","notesActionCreator","routingActionCreator","list","noteContent","takeNote","querySelectorAll","forEach","ev","preventDefault","navigate","subscription","subscribe","state","applyStoreState","note","notes","li","createElement","innerText","DeviceLinkStatus","Paths","MessageTypes","deviceLinkActionCreator","invitePane","processStartPane","generateButton","pasteButton","invCode","pastedCode","style","display","startDeviceLinking","linkDevice","deviceLink","inviteCode","deviceLinkStatus","Uninitialized","currentRoute","router","FirstTimeInit","LinkDevice","component","addServices","initState","subscriptions","reducerSubscriptions","area","sub","push","splice","indexOf","reducer","action","updatedAreas","applyUpdateFn","cb","onDispatch","NotesActionNames","TakeNote","type","NotesActionCreator","localAppendOnlyLogService","messageEncoder","appendOnlyLog","addMessage","encodeNote","dispatch","appendOnlyLogCreated","getAll","entry","msg","JSON","parse","TextDecoder","decode","subarray","Note","navigateFirstTimeInit","navigateHome","toBase64UrlSafe","b","uint8Array","end","byteLength","btoa","String","fromCharCode","signingKey","persistence","beforeDigest","getLastMessage","createLogMessage","storeMessages","Date","encoded","beforeHash","TextEncoder","encode","uint8ArrayView","mergedArray","encodedContent","digest","subtle","digestMessage","sign","MessageModifier","messageFactory","hasAppendOnlyLog","keyPair","generateKey","namedCurve","createAppendOnlyLog","localAppendOnlyLog","encodePublicKeyMessage","getAppendOnlyLog","PublicKey","stringify","res","DataView","buffer","setInt32","Public","Home","path","updateStore","ServiceLocator","iceConfig","iceServers","EventTarget","connectionId","signallingClient","candidate","rtcConnection","addIceCandidate","answer","setRemoteDescription","resolveInit","offer","resolveConnectionRequest","reason","rejectConnectionRequest","dispatchEvent","Event","channel","timeout","RTCPeerConnection","dataChannel","createDataChannel","onopen","onDataChannelOpen","onicecandidate","publishIceCandidate","createOffer","initiateConnection","setLocalDescription","resolved","setTimeout","close","ondatachannel","datachannel","requestConnection","createAnswer","sendAnswer","rejectConenctionRequest","SignallingActionNames","localId","handlers","self","socket","WebSocket","send","onerror","console","onclose","connect","onmessage","parsed","data","find","v","acknowledgeInit","setOffer","setAnswer","handler","initiateChannel","connectionHandler","openChannel","SignallingConnectionChanged","connected","SignallingActionCreator","signallingConnected","DeviceLinkActionNames","DeviceLinkChannelInitialized","DeviceLinkStatusChanged","status","deviceLinkChannel","initializeDeviceLinkChannel","openDeviceLinkChannel","err","Error","Started","addReducer","initializationActionCreator","signallingActionCreator","setServiceLocator","initialize","run","initializeApplication","startSignalling"],"mappings":"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","file":"dff5e384fc8b32799ea1.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","// Module\nvar code = \"<div> <h1> Welcome to greenchat! </h1> <p>Your device is being prepared, please hold on.</p> </div>\";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h1>Greenchat Home</h1> <nav> <a href=link-device>Link Device</a> </nav> <h2>List of your notes</h2> <ol id=notes-list> </ol> <div> <p>Add a note</p> <div> <input type=text id=note-content /> </div> <div> <button type=button id=addNoteBtn>Add Note</button> </div> </div>\";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h1>Link another of your devices to this account</h1> <div id=process-start-pane> <p>On the first device generate device invite code: <button type=button id=generate>Start</button></p> <p> On the second device paste the invite code: </p><div> <input type=text id=pasted-code /> <button id=redeem-code>redeem code</button> </div> <p></p> </div> <div id=invite-code-pane> Invite-Code: <span id=inv-code></span> </div>\";\n// Exports\nmodule.exports = code;","class t{constructor(t,e){this.routeResolver=t,this.routeRenderer=e,this.lastRoute=null,this.popStateListener=this.handlePopState.bind(this)}handlePopState(t){this.doRouting(window.location.pathname)}run(){let t=document.querySelector(\"base\");this.basePrefix=t.getAttribute(\"href\"),this.baseHref=t.href,window.addEventListener(\"popstate\",this.popStateListener),this.doRouting(window.location.pathname)}destroy(){window.removeEventListener(\"popstate\",this.popStateListener)}doRouting(t){let e=this.getRoute(t),n=this.routeResolver.resolve(this.lastRoute,e,this);return!!n&&(this.routeRenderer.render(n),this.lastRoute=e,!0)}getRoute(t){let e=t===this.baseHref,n=t.substr(0,this.basePrefix.length)===this.basePrefix;return e?\"/\":n?t.substring(this.basePrefix.length):t}navigate(t,e){let n=new URL(t,this.baseHref);this.doRouting(n.pathname)&&window.history.pushState({},e||document.title,n.href)}}class e{constructor(){this.currentComponent=null}render(t){t&&(this.currentComponent&&document.body.removeChild(this.currentComponent),document.body.appendChild(t),this.currentComponent=t)}}class n{constructor(t){this.container=t,this.currentComponent=!1}render(t){t&&(this.currentComponent&&(this.container.innerHTML=\"\"),this.container.appendChild(t),this.currentComponent=!0)}}export{e as BodyChildRouteRenderer,n as ContainerRouteRenderer,t as Router};\n//# sourceMappingURL=index.js.map\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { r as replaceTraps, i as instanceOfAny, a as reverseTransformCache, u as unwrap } from './wrap-idb-value.js';\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n","export class LogMessage {\n    constructor(public content: ArrayBuffer, public hash: string, public last: string, public signature: string, public timestamp: number, public sequence: number) {\n    }\n}\n","export function uuid() {\n    return ((<string><unknown>[1e7]) + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n        (<number><unknown>c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> <number><unknown>c / 4).toString(16)\n    );\n}","import \"idb/with-async-ittr\";\nimport { openDB, IDBPDatabase } from \"idb\";\nimport { LogPersistence } from \"../append-only-log/LogPersistence\";\nimport { LogMessage } from \"../append-only-log/LogMessage\";\nimport { uuid } from \"../utils/uuid\";\nimport { AppendOnlyLogMetadata } from \"../append-only-log/AppendOnlyLogMetadata\";\n\nconst AppendOnlyLogMessages = \"AppendOnlyLogMessages\";\nconst AppendOnlyLogs = \"AppendOnlyLogs\";\n\nexport class GreenchatDatabase implements LogPersistence {\n    async getAppendOnlyLog(logId: string): Promise<AppendOnlyLogMetadata> {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        return {\n            logId: logId,\n            privateKey: log.privateKey,\n            publicKey: log.publicKey,\n            sequence: log.sequence\n        };\n    }\n    async getLastMessage(logId: string): Promise<LogMessage> {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        if (null == log.top) {\n            return null;\n        }\n        let msgData = await this.db.get(AppendOnlyLogMessages, log.top);\n        return new LogMessage(msgData.content, msgData.hash, msgData.last, msgData.signature, msgData.timestamp, msgData.sequence);\n    }\n    async storeMessages(logId: string, messages: LogMessage[]): Promise<boolean> {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        const tx = this.db.transaction(AppendOnlyLogMessages, \"readwrite\");\n        let { top } = log;\n        let sequence = null;\n        for (let m of messages) {\n            let storeObj = { ...m, logId, id: uuid(), before: top };\n            await tx.store.add(storeObj);\n            top = storeObj.id;\n            sequence = storeObj.sequence;\n        }\n        await tx.done;\n        log.top = top;\n        log.sequence = sequence;\n        await this.db.put(AppendOnlyLogs, log);\n        return true;\n    }\n    db: IDBPDatabase<unknown>;\n    async initialize() {\n        this.db = await openDB(\"greenchat-dbv2\", 1, {\n            upgrade(db) {\n                let store = db.createObjectStore(AppendOnlyLogMessages, { keyPath: \"id\" });\n                store.createIndex(\"logId\", \"logId\");\n                db.createObjectStore(AppendOnlyLogs, { keyPath: \"id\" });\n            },\n        });\n    }\n    async hasAppendOnlyLog(logId: string) {\n        return !! await this.db.get(AppendOnlyLogs, logId);\n    }\n    async createAppendOnlyLog(logId: string, publicKey: CryptoKey, privateKey: CryptoKey) {\n        await this.db.add(AppendOnlyLogs, { id: logId, privateKey, publicKey, sequence: 0, top: null });\n    }\n    async addMessage(logId: string, m: LogMessage) {\n        let log = await this.db.get(AppendOnlyLogs, logId);\n        let storeObj = { ...m, logId, id: uuid(), before: log.top };\n        await this.db.add(AppendOnlyLogMessages, storeObj);\n        log.top = storeObj.id;\n        log.sequence = storeObj.sequence;\n        await this.db.put(AppendOnlyLogs, log);\n    }\n\n    async *getAll(logId: string): AsyncGenerator<LogMessage, void, unknown> {\n        const index = this.db.transaction(AppendOnlyLogMessages).store.index('logId');\n        for await (const cursor of index.iterate(logId)) {\n            let item = cursor.value;\n            yield new LogMessage(item.content, item.hash, item.last, item.signature, item.timestamp,\n                item.sequence);\n        }\n    }\n}\n","import template from \"./first-time-init.html\";\n\nexport class FirstTimeInit extends HTMLElement {\n\n    constructor() {\n        super();\n        this.innerHTML = template;\n    }\n\n    connectedCallback() {\n\n    }\n}\n\ncustomElements.define('app-first-time-init', FirstTimeInit);","import template from \"./home.html\";\nimport { Store } from \"../state/Store\";\nimport { NotesActionCreator } from \"../state/actions/NotesActionCreator\";\nimport { ServiceLocator } from \"../ServiceLocator\";\nimport { RoutingActionCreator } from \"../state/actions/RoutingActionCreator\";\nimport { State } from \"../state/State\";\n\nexport class Home extends HTMLElement {\n    store: Store;\n    notesActionCreator: NotesActionCreator;\n    list: HTMLOListElement;\n    noteContent: HTMLInputElement;\n    subscription: () => void;\n    routingActionCreator: RoutingActionCreator;\n\n    constructor() {\n        super();\n        this.innerHTML = template;\n    }\n\n    addServices(serviceLocator: ServiceLocator) {\n        this.store = serviceLocator.store;\n        this.notesActionCreator = serviceLocator.notesActionCreator;\n        this.routingActionCreator = serviceLocator.routingActionCreator;\n    }\n\n    connectedCallback() {\n        let element = this;\n        this.list = element.querySelector(\"#notes-list\");\n        this.noteContent = element.querySelector(\"#note-content\");\n        element.querySelector(\"#addNoteBtn\").addEventListener(\"click\", () => {\n            this.notesActionCreator.takeNote(this.noteContent.value);\n            this.noteContent.value = \"\";\n        })\n        element.querySelectorAll(\"a\").forEach(e => {\n            e.addEventListener(\"click\", ev => {\n                ev.preventDefault();\n                this.routingActionCreator.navigate(e.getAttribute(\"href\"))\n            });\n        });\n        this.subscription = this.store.subscribe(\"notes\", state => this.applyStoreState(state));\n        this.applyStoreState(this.store.state);\n    }\n\n    private applyStoreState(state: State) {\n        this.list.innerHTML = \"\";\n        for (let note of state.notes.notes) {\n            let li = document.createElement(\"li\");\n            li.innerText = note;\n            this.list.appendChild(li);\n        }\n    }\n\n    disconnectedCallback() {\n        this.subscription();\n    }\n}\n\ncustomElements.define('app-home', Home);","export enum DeviceLinkStatus {\n    Started,\n    Succeeded,\n    Error,\n    Uninitialized\n}\n","import { Router } from \"route-it\";\nimport { FirstTimeInit } from \"../components/first-time-init\";\nimport { Home } from \"../components/home\";\nimport { Store } from \"../state/Store\";\nimport { NotesActionCreator } from \"../state/actions/NotesActionCreator\";\nimport { ServiceLocator } from \"../ServiceLocator\";\nimport { LinkDevice } from \"../components/link-device\";\n\nexport enum Paths {\n    FirstTimeInit = \"first-time-init\",\n    LinkDevice = \"link-device\",\n    Home = \"\"\n}\n\nexport class GreenchatRouteResolver {\n    serviceLocator: ServiceLocator;\n    setServiceLocator(serviceLocator: ServiceLocator) {\n        this.serviceLocator = serviceLocator;\n    }\n\n    resolve(lastRoute: string, currentRoute: string, router: Router<HTMLElement>) {\n        switch (currentRoute) {\n            case Paths.FirstTimeInit:\n                return new FirstTimeInit();\n            case Paths.LinkDevice: {\n                let component = new LinkDevice();\n                component.addServices(this.serviceLocator);\n                return component;\n            }\n            default:\n                let component = new Home();\n                component.addServices(this.serviceLocator);\n                return component;\n        }\n    }\n}\n","export enum MessageTypes {\n    PublicKey = \"PublicKey\",\n    Note = \"Note\"\n}\n","import template from \"./link-device.html\";\nimport { Store } from \"../state/Store\";\nimport { ServiceLocator } from \"../ServiceLocator\";\nimport { DeviceLinkActionCreator } from \"../state/actions/DeviceLinkActionCreator\";\nimport { DeviceLinkStatus } from \"../models/DeviceLinkStatus\";\nimport { State } from \"../state/State\";\n\nexport class LinkDevice extends HTMLElement {\n    store: Store;\n    deviceLinkActionCreator: DeviceLinkActionCreator;\n    invitePane: HTMLDivElement;\n    processStartPane: HTMLDivElement;\n    generateButton: HTMLButtonElement;\n    pasteButton: HTMLButtonElement;\n    invCode: HTMLSpanElement;\n    pastedCode: HTMLInputElement;\n    subscription: () => void;\n\n    constructor() {\n        super();\n        this.innerHTML = template;\n    }\n\n    addServices(serviceLocator: ServiceLocator) {\n        this.store = serviceLocator.store;\n        this.deviceLinkActionCreator = serviceLocator.deviceLinkActionCreator;\n    }\n\n    connectedCallback() {\n        let element = this;\n        this.invitePane = element.querySelector(\"#invite-code-pane\");\n        this.processStartPane = element.querySelector(\"#process-start-pane\");\n        this.generateButton = element.querySelector(\"#generate\");\n        this.pasteButton = element.querySelector(\"#redeem-code\");\n        this.invCode = element.querySelector(\"#inv-code\");\n        this.pastedCode = element.querySelector(\"#pasted-code\");\n        this.invitePane.style.display = \"none\";\n\n        this.generateButton.addEventListener(\"click\", async () => {\n            await this.deviceLinkActionCreator.startDeviceLinking();\n        });\n\n        this.pasteButton.addEventListener(\"click\", async () => {\n            await this.deviceLinkActionCreator.linkDevice(this.pastedCode.value);\n        });\n\n        this.subscription = this.store.subscribe(\"deviceLink\", state => this.applyStoreState(state));\n        this.applyStoreState(this.store.state);\n    }\n\n    private applyStoreState(state : State) {\n        this.invitePane.style.display = state.deviceLink.inviteCode ? \"block\" : \"none\";\n            this.invCode.innerText = state.deviceLink.inviteCode;\n            this.processStartPane.style.display = state.deviceLink.deviceLinkStatus == DeviceLinkStatus.Uninitialized ? \"block\" : \"none\";\n    }\n\n    disconnectedCallback() {\n        this.subscription();\n    }\n}\n\ncustomElements.define('app-link-device', LinkDevice);\n","import { State } from \"./State\";\nimport { BaseStore } from \"./lib/BaseStore\";\n\nexport class Store extends BaseStore<State> {\n    \n};","import { Reducer } from \"./Reducer\";\nimport { Action } from \"./Action\";\n\ninterface Subscription<TState> {\n    call(a: TState): void;\n    area: keyof TState | \"\";\n}\n\ninterface ReducerSubscription<TState> {\n    reducer: Reducer<any, any>;\n    area: keyof TState | null;\n}\n\nexport class BaseStore<TState> {\n    public state: TState;\n    private subscriptions: Subscription<TState>[];\n    private reducerSubscriptions: ReducerSubscription<TState>[];\n    constructor(initState: () => TState) {\n        this.subscriptions = [];\n        this.reducerSubscriptions = [];\n        this.state = initState();\n    }\n    subscribe(area: keyof TState, call: (a: TState) => void) {\n        let sub = { area, call };\n        this.subscriptions.push(sub);\n        return () => {\n            this.subscriptions.splice(this.subscriptions.indexOf(sub), 1);\n        };\n    }\n    addReducer<K extends keyof TState>(area: K | null, reducer: Reducer<TState[K] | TState, any>) {\n        this.reducerSubscriptions.push({ area, reducer });\n    }\n    dispatch(action: Action) {\n        let updatedAreas: (keyof TState | \"\")[] = [];\n        for (let s of this.reducerSubscriptions) {\n            let applyUpdateFn;\n            if (s.area) {\n                applyUpdateFn = (cb: (a: any) => any) => {\n                    (<any>this.state[s.area]) = cb(this.state[s.area]);\n                    updatedAreas.push(s.area);\n                };\n            }\n            else {\n                applyUpdateFn = (cb: (a: any) => any) => {\n                    this.state = cb(this.state);\n                    updatedAreas.push(\"\");\n                };\n            }\n            s.reducer.onDispatch(action, applyUpdateFn);\n        }\n        if (updatedAreas.length) {\n            for (let s of this.subscriptions) {\n                if (!s.area || updatedAreas.indexOf(s.area) > -1) {\n                    s.call(this.state);\n                }\n            }\n        }\n    }\n}\n","import { Store } from \"../Store\";\nimport { Action } from \"../lib/Action\";\nimport { LocalAppendOnlyLogService } from \"../../append-only-log/LocalAppendOnlyLogService\";\nimport { MessageEncoder } from \"../../message-encoding/MessageEncoder\";\n\nexport enum NotesActionNames {\n    TakeNote = \"TakeNote\"\n}\n\nexport class TakeNote implements Action {\n    readonly type = NotesActionNames.TakeNote;\n    constructor(public content: string) {\n\n    }\n}\n\nexport type NotesActions = TakeNote;\n\nexport class NotesActionCreator {\n    constructor(private store: Store,\n         private localAppendOnlyLogService : LocalAppendOnlyLogService,\n         private messageEncoder : MessageEncoder) {\n\n    }\n    async takeNote(content: string) {\n        let appendOnlyLog = await this.localAppendOnlyLogService.get(\"local\");\n        await appendOnlyLog.addMessage(this.messageEncoder.encodeNote(content));\n        this.store.dispatch(new TakeNote(content));\n    }\n}","import { RoutingActionCreator } from \"./RoutingActionCreator\";\nimport { LocalAppendOnlyLogService } from \"../../append-only-log/LocalAppendOnlyLogService\";\nimport { Store } from \"../Store\";\nimport { MessageTypes } from \"../../message-encoding/MessageTypes\";\nimport { TakeNote } from \"./NotesActionCreator\";\nexport class InitializationActionCreator {\n    constructor(private store: Store, private localAppendOnlyLogService: LocalAppendOnlyLogService, private routingActionCreator: RoutingActionCreator) {\n    }\n    async initializeApplication() {\n        let appendOnlyLogCreated = await this.localAppendOnlyLogService.appendOnlyLogCreated(\"local\");\n        if (!appendOnlyLogCreated) {\n            this.routingActionCreator.navigateFirstTimeInit();\n            await this.localAppendOnlyLogService.create(\"local\");\n            this.routingActionCreator.navigateHome();\n        } else {\n            let log = await this.localAppendOnlyLogService.get(\"local\");\n            for await (let entry of log.getAll()) {\n                // for now assume public msg\n                let msg = JSON.parse(new TextDecoder().decode(new Uint8Array(entry.content).subarray(2)));\n                if (msg.type == MessageTypes.Note) {\n                    this.store.dispatch(new TakeNote(msg.content));\n                }\n            }\n        }\n    }\n}\n","export function toBase64UrlSafe(b: ArrayBuffer) {\n    let uint8Array = new Uint8Array(b);\n    let start = 0;\n    let end = uint8Array.byteLength;\n\n    const base64 = window.btoa(\n        String.fromCharCode.apply(null, uint8Array.subarray(start, end)));\n    return base64\n        .replace(/\\=/g, '') // eslint-disable-line no-useless-escape\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_');\n}","import { LogMessage } from \"./LogMessage\";\nimport { toBase64UrlSafe } from \"../utils/toBase64UrlSafe\";\nimport { digestMessage } from \"./digestMessage\";\nimport { LogPersistence } from \"./LogPersistence\";\n\nexport class LocalAppendOnlyLog {\n\n    constructor(private signingKey: CryptoKey,\n        private logId: string,\n        private sequence: number,\n        private persistence: LogPersistence) {\n    }\n\n    async addMessage(content: ArrayBuffer) {\n        let beforeDigest;\n        if (this.sequence == 0) {\n            beforeDigest = \"initial\";\n        }\n        else {\n            let last = await this.persistence.getLastMessage(this.logId);\n            beforeDigest = last.hash;\n        }\n        let sequence = this.sequence + 1;\n        let msg = await this.createLogMessage(content, beforeDigest, sequence);\n        await this.persistence.storeMessages(this.logId, [msg]);\n        this.sequence = sequence;\n    }\n\n    private async createLogMessage(content: ArrayBuffer, beforeDigest: string, sequence: number): Promise<LogMessage> {\n        let timestamp = +new Date();\n        let encoded = await digestMessage(beforeDigest, content, timestamp);\n        let signature = await crypto.subtle.sign({ name: \"ECDSA\", hash: \"SHA-256\" }, this.signingKey, encoded.encodedContent);\n        return new LogMessage(content, toBase64UrlSafe(encoded.digest), beforeDigest, toBase64UrlSafe(signature), timestamp, sequence);\n    }\n\n    getAll(): AsyncGenerator<LogMessage, void, unknown> {\n        return this.persistence.getAll(this.logId);\n    }\n}","export async function digestMessage(beforeHash: string, content: ArrayBuffer, timestamp: number) {\n    let encoder = new TextEncoder();\n    let encoded = encoder.encode(`${timestamp}.${beforeHash}`);\n    let uint8ArrayView = new Uint8Array(content);\n    let mergedArray = new Uint8Array(encoded.length + uint8ArrayView.length);\n    mergedArray.set(encoded);\n    mergedArray.set(uint8ArrayView, encoded.length);\n    let digest = await crypto.subtle.digest(\"SHA-256\", encoded);\n    return {\n        encodedContent: encoded,\n        digest: digest\n    };\n}\n","export enum MessageModifier {\n    Public = 1\n}\n","import { LocalAppendOnlyLog } from \"./LocalAppendOnlyLog\";\nimport { MessageEncoder } from \"../message-encoding/MessageEncoder\";\nimport { LogPersistence } from \"./LogPersistence\";\n\nexport class LocalAppendOnlyLogService {\n    constructor(private persistence: LogPersistence, private messageFactory: MessageEncoder) {\n    }\n    async appendOnlyLogCreated(logId: string) {\n        return await this.persistence.hasAppendOnlyLog(logId);\n    }\n    async create(logId: string) {\n        let keyPair = await crypto.subtle.generateKey({ name: \"ECDSA\", namedCurve: \"P-256\" }, false, [\"sign\", \"verify\"]);\n        await this.persistence.createAppendOnlyLog(logId, keyPair.publicKey, keyPair.privateKey);\n        let localAppendOnlyLog = new LocalAppendOnlyLog(keyPair.privateKey, \"local\", 0, this.persistence);\n        await localAppendOnlyLog.addMessage(this.messageFactory.encodePublicKeyMessage(keyPair.publicKey));\n    }\n    async get(logId: string) {\n        let appendOnlyLog = await this.persistence.getAppendOnlyLog(logId);\n        return new LocalAppendOnlyLog(appendOnlyLog.privateKey, logId, appendOnlyLog.sequence, this.persistence);\n    }\n}\n","import { MessageTypes } from \"./MessageTypes\";\nimport { MessageModifier } from \"./MessageModifier\";\nexport class MessageEncoder {\n    encodePublicKeyMessage(publicKey: CryptoKey): ArrayBuffer {\n        let msg = { publicKey, type: MessageTypes.PublicKey };\n        let encoder = new TextEncoder();\n        let encoded = encoder.encode(JSON.stringify(msg));\n        let res = new Uint8Array(encoded.length + 2);\n        new DataView(res.buffer).setInt32(0, MessageModifier.Public, true);\n        res.set(encoded, 2);\n        return res.buffer;\n    }\n    encodeNote(content: string): ArrayBuffer {\n        let msg = { content, type: MessageTypes.Note };\n        let encoder = new TextEncoder();\n        let encoded = encoder.encode(JSON.stringify(msg));\n        let res = new Uint8Array(encoded.length + 2);\n        new DataView(res.buffer).setInt32(0, MessageModifier.Public, true);\n        res.set(encoded, 2);\n        return res.buffer;\n    }\n}\n","import { Router } from \"route-it\";\nimport { Paths } from \"../../routing/GreenchatRouteResolver\";\nexport class RoutingActionCreator {\n    constructor(private router: Router<HTMLElement>) {\n    }\n    navigateFirstTimeInit() {\n        this.router.navigate(Paths.FirstTimeInit, null);\n    }\n    navigateHome() {\n        this.router.navigate(Paths.Home, null);\n    }\n\n    navigate(path: string) {\n        this.router.navigate(path, null);\n    }\n}\n","import { Reducer } from \"../lib/Reducer\";\nimport { NotesSubState } from \"../State\";\nimport { NotesActions, NotesActionNames } from \"../actions/NotesActionCreator\";\n\nexport class NotesReducer implements Reducer<NotesSubState, NotesActions> {\n    onDispatch(action: NotesActions, updateStore: (a: (s: NotesSubState) => NotesSubState) => void): void {\n        switch (action.type) {\n            case NotesActionNames.TakeNote: {\n                updateStore((s: NotesSubState) => {\n                    let notes = s.notes || [];\n                    notes.push(action.content);\n                    return { ...s, notes };\n                })\n            }\n        }\n    }\n}","import { Store } from \"./state/Store\";\nimport { NotesActionCreator } from \"./state/actions/NotesActionCreator\";\nimport { DeviceLinkActionCreator } from \"./state/actions/DeviceLinkActionCreator\";\nimport { RoutingActionCreator } from \"./state/actions/RoutingActionCreator\";\n\nexport class ServiceLocator {\n    constructor(public store: Store,\n        public notesActionCreator: NotesActionCreator,\n        public deviceLinkActionCreator: DeviceLinkActionCreator,\n        public routingActionCreator : RoutingActionCreator) {\n\n    }\n}","export const iceConfig =  { iceServers: [{\"urls\":[\"turn:turn.greenchat.me:443\"],\"username\":\"raphael\",\"credential\":\"@123@test@\"}] };\nexport const signallingServer = \"ws://localhost:33713\";","import { iceConfig } from \"./config\";\nimport { SignallingClient } from \"./SignallingClient\";\nimport { ChannelInitialization } from \"./ChannelInitialization\";\nimport { DataChannelOpenedEventInit } from \"./DataChannelOpenedEventInit\";\nexport class PeerConnectionHandler extends EventTarget {\n    private rtcConnection: RTCPeerConnection;\n    private resolveInit: () => void;\n    private resolveConnectionRequest: (offer: RTCSessionDescriptionInit) => void;\n    private rejectConnectionRequest: (reason: string) => void;\n    constructor(public connectionId: string, private signallingClient: SignallingClient) {\n        super();\n    }\n    addIceCandidate(candidate: RTCIceCandidateInit) {\n        this.rtcConnection.addIceCandidate(candidate);\n    }\n    setAnswer(answer: RTCSessionDescriptionInit) {\n        this.rtcConnection.setRemoteDescription(answer);\n    }\n    acknowledgeInit() {\n        this.resolveInit();\n    }\n    setOffer(offer: RTCSessionDescriptionInit) {\n        this.resolveConnectionRequest(offer);\n    }\n    rejectConenctionRequest(reason: string) {\n        this.rejectConnectionRequest(reason);\n    }\n    private onDataChannelOpen(c: RTCDataChannel) {\n        this.dispatchEvent(new Event(\"datachannelopen\", <DataChannelOpenedEventInit>{ channel: c }));\n    }\n    initiateChannel(timeout: number): Promise<unknown> {\n        this.rtcConnection = new RTCPeerConnection({ ...iceConfig });\n        let dataChannel = this.rtcConnection.createDataChannel(\"sendChannel\");\n        dataChannel.onopen = () => this.onDataChannelOpen(dataChannel);\n        this.rtcConnection.onicecandidate = ({ candidate }) => {\n            if (candidate) {\n                this.signallingClient.publishIceCandidate(this.connectionId, candidate);\n            }\n        };\n        this.rtcConnection.createOffer().then(offer => {\n            this.signallingClient.initiateConnection(this.connectionId, timeout, offer);\n            this.rtcConnection.setLocalDescription(offer);\n        });\n        let promise = new Promise<ChannelInitialization>((resolve, reject) => {\n            let resolved = false;\n            this.resolveInit = () => {\n                resolved = true;\n                resolve();\n            };\n            setTimeout(() => {\n                if (!resolved) {\n                    reject(\"Timeout\");\n                    this.rtcConnection.close();\n                }\n            }, 2000);\n        });\n        return promise;\n    }\n    openChannel(): Promise<unknown> {\n        this.rtcConnection = new RTCPeerConnection({ ...iceConfig });\n        this.rtcConnection.onicecandidate = ({ candidate }) => {\n            if (candidate) {\n                this.signallingClient.publishIceCandidate(this.connectionId, candidate);\n            }\n        };\n        this.rtcConnection.ondatachannel = e => {\n            let datachannel = e.channel;\n            datachannel.onopen = () => {\n                this.onDataChannelOpen(datachannel);\n            };\n        };\n        this.signallingClient.requestConnection(this.connectionId);\n        let promise = new Promise<unknown>((resolve, reject) => {\n            let resolved = false;\n            this.resolveConnectionRequest = (offer: RTCSessionDescriptionInit) => {\n                this.rtcConnection.setRemoteDescription(offer).then(() => {\n                    this.rtcConnection.createAnswer().then(answer => {\n                        this.rtcConnection.setLocalDescription(answer);\n                        this.signallingClient.sendAnswer(this.connectionId, answer);\n                        resolved = true;\n                        resolve();\n                    });\n                });\n            };\n            this.rejectConenctionRequest = (msg: string) => {\n                resolved = true;\n                reject(msg);\n                this.rtcConnection.close();\n            };\n            setTimeout(() => {\n                if (!resolved) {\n                    reject(\"Timeout\");\n                    this.rtcConnection.close();\n                }\n            }, 10000);\n        });\n        return promise;\n    }\n}\n","import { Store } from \"../Store\";\nimport { Action } from \"../lib/Action\";\nimport { SignallingClient } from \"../../webrtc/SignallingClient\";\n\nexport enum SignallingActionNames {\n    SignallingConnectionChanged = \"SignallingConnectionChanged\"\n}\n\nexport class SignallingConnectionChanged implements Action {\n    readonly type = SignallingActionNames.SignallingConnectionChanged;\n    constructor(public connected: boolean) {\n\n    }\n}\n\nexport type SignallingActions = SignallingConnectionChanged;\n\nexport class SignallingActionCreator {\n    constructor(private store: Store, private signallingClient: SignallingClient) {\n        this.signallingClient.addEventListener(\"connected\", () => {\n            this.store.dispatch(new SignallingConnectionChanged(true));\n        });\n        this.signallingClient.addEventListener(\"disconnected\", () => {\n            this.store.dispatch(new SignallingConnectionChanged(false));\n        });\n    }\n\n    startSignalling() {\n        this.signallingClient.connect();\n    }\n}","import { uuid } from \"../utils/uuid\";\nimport { signallingServer } from \"./config\";\nimport { PeerConnectionHandler } from \"./PeerConnectionHandler\";\nimport { ChannelInitialization } from \"./ChannelInitialization\";\n\nexport class SignallingClient extends EventTarget {\n    private localId: string;\n    private handlers: PeerConnectionHandler[];\n    private socket: WebSocket;\n\n    constructor() {\n        super();\n        this.localId = uuid();\n        this.handlers = [];\n    }\n\n    connect() {\n        let self = this;\n        let socket = this.socket = new WebSocket(signallingServer);\n        socket.onopen = function () {\n            socket.send(JSON.stringify({ type: \"connected\", id: self.localId }));\n            this.dispatchEvent(new Event(\"connected\"));\n        };\n        socket.onerror = function (error) {\n            console.log('WebSocket Error ' + error);\n            socket.close();\n        };\n        socket.onclose = function (e) {\n            console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);\n            this.dispatchEvent(new Event(\"disconnected\"));\n            setTimeout(function () {\n                self.connect();\n            }, 1000);\n        }\n        socket.onmessage = function (e) {\n            let parsed = JSON.parse(e.data);\n            switch (parsed.type) {\n                case \"connection_initialized\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId).acknowledgeInit();\n                    break;\n                case \"connection_offer\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .setOffer(parsed.offer);\n                    break;\n                case \"connection_accepted\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .setAnswer(parsed.answer);\n                    break;\n                case \"connection_not_found\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .rejectConenctionRequest(\"Not found\");\n                    break;\n                case \"new_ice_candidate\":\n                    self.handlers.find(v => v.connectionId === parsed.connectionId)\n                        .addIceCandidate(parsed.candidate);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    async initializeDeviceLinkChannel(timeout: number): Promise<ChannelInitialization> {\n        let handler = new PeerConnectionHandler(uuid(), this);\n        this.handlers.push(handler);\n        await handler.initiateChannel(timeout);\n        return {\n            connectionHandler: handler\n        };\n    }\n\n    async openDeviceLinkChannel(connectionId: string): Promise<ChannelInitialization> {\n        let handler = new PeerConnectionHandler(connectionId, this);\n        this.handlers.push(handler);\n        await handler.openChannel();\n        return {\n            connectionHandler: handler\n        };\n    }\n    requestConnection(connectionId: string) {\n        this.socket.send(JSON.stringify({ type: \"request_connection\", connectionId }));\n    }\n\n    sendAnswer(connectionId: string, answer: RTCSessionDescriptionInit) {\n        this.socket.send(JSON.stringify({ type: \"accept_connection\", connectionId, answer }));\n    }\n\n    initiateConnection(connectionId: string, timeout: number, offer: RTCSessionDescriptionInit) {\n        this.socket.send(JSON.stringify({ type: \"initialize_connection\", connectionId, timeout, offer }));\n    }\n\n    publishIceCandidate(connectionId: string, candidate: RTCIceCandidateInit) {\n        this.socket.send(JSON.stringify({\n            type: \"new_ice_candidate\",\n            candidate,\n            id: this.localId,\n            connectionId: connectionId\n        }));\n    }\n}","import { Reducer } from \"../lib/Reducer\";\nimport { State } from \"../State\";\nimport { SignallingActions, SignallingActionNames } from \"../actions/SignallingActionCreator\";\n\nexport class GlobalReducer implements Reducer<State, SignallingActions> {\n    onDispatch(action: SignallingActions, updateStore: (a: (s: State) => State) => void): void {\n        switch (action.type) {\n            case SignallingActionNames.SignallingConnectionChanged: {\n                updateStore(s => {\n                    return { ...s, signallingConnected: action.connected };\n                })\n            }\n        }\n    }\n}","import { Store } from \"../Store\";\nimport { Action } from \"../lib/Action\";\nimport { SignallingClient } from \"../../webrtc/SignallingClient\";\nimport { DeviceLinkStatus } from \"../../models/DeviceLinkStatus\";\n\nexport enum DeviceLinkActionNames {\n    DeviceLinkChannelInitialized = \"DeviceLinkChannelInitialized\",\n    DeviceLinkStatusChanged = \"DeviceLinkStatusChanged\"\n}\n\nexport class DeviceLinkChannelInitialized implements Action {\n    readonly type = DeviceLinkActionNames.DeviceLinkChannelInitialized;\n    constructor(public connectionId: string) {\n\n    }\n}\n\nexport class DeviceLinkStatusChanged implements Action {\n    readonly type = DeviceLinkActionNames.DeviceLinkStatusChanged;\n    constructor(public status: DeviceLinkStatus) {\n\n    }\n}\n\nexport type DeviceLinkActions = DeviceLinkChannelInitialized | DeviceLinkStatusChanged;\n\nexport class DeviceLinkActionCreator {\n    constructor(private store: Store, private signallingClient: SignallingClient) {\n    }\n\n    async startDeviceLinking() {\n        let deviceLinkChannel = await this.signallingClient.initializeDeviceLinkChannel(120000);\n        deviceLinkChannel.connectionHandler.addEventListener(\"datachannelopen\", e => {\n            console.log(\"connected\");\n        });\n        this.store.dispatch(new DeviceLinkChannelInitialized(deviceLinkChannel.connectionHandler.connectionId));\n    }\n\n    async linkDevice(connectionId: string) {\n        try {\n            let deviceLinkChannel = await this.signallingClient.openDeviceLinkChannel(connectionId);\n            deviceLinkChannel.connectionHandler.addEventListener(\"datachannelopen\", e => {\n                console.log(\"connected\");\n            });\n        }\n        catch (err) {\n            this.store.dispatch(new DeviceLinkStatusChanged(DeviceLinkStatus.Error));\n        }\n    }\n}","import { Reducer } from \"../lib/Reducer\";\nimport { DeviceLinkState } from \"../State\";\nimport { DeviceLinkActions, DeviceLinkActionNames } from \"../actions/DeviceLinkActionCreator\";\nimport { DeviceLinkStatus } from \"../../models/DeviceLinkStatus\";\n\nexport class DeviceLinkReducer implements Reducer<DeviceLinkState, DeviceLinkActions> {\n    onDispatch(action: DeviceLinkActions, updateStore: (a: (s: DeviceLinkState) => DeviceLinkState) => void): void {\n        switch (action.type) {\n            case DeviceLinkActionNames.DeviceLinkChannelInitialized:\n                updateStore((s) => {\n                    return {\n                        ...s, inviteCode: action.connectionId,\n                        deviceLinkStatus: DeviceLinkStatus.Started\n                    };\n                });\n                break;\n            case DeviceLinkActionNames.DeviceLinkStatusChanged:\n                updateStore((s) => {\n                    return {\n                        ...s,\n                        deviceLinkStatus: action.status\n                    };\n                });\n                break;\n        }\n    }\n}","import { Router, BodyChildRouteRenderer } from \"route-it\";\nimport { GreenchatDatabase } from \"./database/GreenchatDatabase\";\nimport { GreenchatRouteResolver } from \"./routing/GreenchatRouteResolver\";\nimport { Store } from \"./state/Store\";\nimport { InitializationActionCreator } from \"./state/actions/InitializationActionCreator\";\nimport { LocalAppendOnlyLogService } from \"./append-only-log/LocalAppendOnlyLogService\";\nimport { MessageEncoder } from \"./message-encoding/MessageEncoder\";\nimport { RoutingActionCreator } from \"./state/actions/RoutingActionCreator\";\nimport { NotesReducer } from \"./state/reducers/NotesReducer\";\nimport { NotesActionCreator } from \"./state/actions/NotesActionCreator\";\nimport { ServiceLocator } from \"./ServiceLocator\";\nimport { SignallingClient } from \"./webrtc/SignallingClient\";\nimport { GlobalReducer } from \"./state/reducers/GlobalReducer\";\nimport { SignallingActionCreator } from \"./state/actions/SignallingActionCreator\";\nimport { DeviceLinkActionCreator } from \"./state/actions/DeviceLinkActionCreator\";\nimport { DeviceLinkStatus } from \"./models/DeviceLinkStatus\";\nimport { DeviceLinkReducer } from \"./state/reducers/DeviceLinkReducer\";\n\nasync function run() {\n    const db = new GreenchatDatabase();\n    const signallingClient = new SignallingClient();\n    const routeResolver = new GreenchatRouteResolver();\n    const router = new Router(routeResolver, new BodyChildRouteRenderer());\n    const store = new Store(() => {\n        return {\n            signallingConnected: false,\n            notes: { notes: [] },\n            deviceLink: {\n                deviceLinkStatus: DeviceLinkStatus.Uninitialized,\n                inviteCode: null\n            }\n        }\n    });\n    store.addReducer(\"notes\", new NotesReducer());\n    store.addReducer(null, new GlobalReducer());\n    store.addReducer(\"deviceLink\", new DeviceLinkReducer());\n\n    const messageEncoder = new MessageEncoder();\n    const localAppendOnlyLogService = new LocalAppendOnlyLogService(db, messageEncoder);\n\n    const routingActionCreator = new RoutingActionCreator(router);\n    const initializationActionCreator = new InitializationActionCreator(store, localAppendOnlyLogService, routingActionCreator);\n    const notesActionCreator = new NotesActionCreator(store, localAppendOnlyLogService, messageEncoder);\n    const signallingActionCreator = new SignallingActionCreator(store, signallingClient);\n    const deviceLinkActionCreator = new DeviceLinkActionCreator(store, signallingClient);\n\n    const serviceLocator = new ServiceLocator(store,\n        notesActionCreator,\n        deviceLinkActionCreator,\n        routingActionCreator);\n    routeResolver.setServiceLocator(serviceLocator);\n\n    await db.initialize();\n    router.run();\n\n    await initializationActionCreator.initializeApplication();\n    signallingActionCreator.startSignalling();\n}\n\nrun().catch(err => console.error(err));\n\n"],"sourceRoot":""}